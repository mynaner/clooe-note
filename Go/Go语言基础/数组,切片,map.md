## Array(数组)

>数组是同一种数据类型元素的集合
>
>数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化

```go
// 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。
// 数组可以通过下标进行访问，下标是从0开始，
// 最后一个元素下标是：len-1，
// 访问越界（下标在合法范围之外），则触发访问越界，会panic。
var 数组变量名 [元素数量]T
```

```go
// 数组初始化1
var testArray [3]int                        //数组会初始化为int类型的零值
var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
var cityArray = [3]string{"北京", "上海", "深圳"} //使用指定的初始值完成初始化
// 数组初始化2
// 编译器根据初始值的个数自行推断数组的长度
var testArray [3]int 	 //[0 0 0]
var numArray = [...]int{1, 2} // [1 2]
var cityArray = [...]string{"北京", "上海", "深圳"} // [北京 上海 深圳]
// 数组初始化3
// 使用指定索引值的方式来初始化数组
a := [...]int{1: 1, 3: 5} // [0 1 0 5]
```

```go
// 数组的遍历
var a = [...]string{ "北京", "上海", "深圳" }
//for i:=0;i<len(a) ;i++  {
//	fmt.Println(a[i])
//}
for index,data:= range a {
  fmt.Println(data,index)
}
```

* 多维数组:多维数组**只有第一层**可以使用`...`来让编译器推导数组长度

* 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。
* 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。
* `[n]*T`表示指针数组，`*[n]T`表示数组指针 。

## 切片

* 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性

* 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

* 切片是一个引用类型，它的内部结构包含`地址`、`长度`和`容量`。切片一般用于快速地操作一块数据集合。

```go
// 声明切片类型的基本语法
var name []T // name:表示变量名 T:表示切片中的元素类型
var a []string              //声明一个字符串切片  声明未初始化所以 a == nil
var b = []int{}             //声明一个整型切片并初始化 
var c = []bool{false, true} //声明一个布尔切片并初始化
var d = []bool{false, true} //声明一个布尔切片并初始化
// 切片拥有自己的长度和容量，使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。
```

* 切片表达式
  * 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。
  * 它有两种变体：
    * 一种指定low和high两个索引界限值的简单的形式，
    * 另一种是除了low和high索引界限值外还指定容量的完整的形式。

```go
a:= [5]int{1,2,3,4,5}
s:= a[0:3]
fmt.Printf("%v len = %v cap = %v",s,len(s),cap(s))
// [1 2 3] len = 3 cap = 5
// 为了方便起见，可以省略切片表达式中的任何索引。
// 省略了low则默认为0；省略了high则默认为切片操作数的长度:
a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
```

* 对于数组或字符串，如果`0 <= low <= high <= len(a)`，则索引合法，否则就会索引越界（out of range）。
* 对切片再执行切片表达式时（切片再切片），`high`的上限边界是切片的容量`cap(a)`，而不是长度。
* **常量索引**必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。
* 如果`low`和`high`两个指标都是常数，它们必须满足`low <= high`。如果索引在运行时超出范围，就会发生运行时`panic`。

* 对于数组，指向数组的指针，或切片a(**注意不能是字符串**)支持完整切片表达式：

  ```go
  a[low : high : max]
  //上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。
  ```

* 完整切片表达式需要满足的条件是`0 <= low <= high <= max <= cap(a)`，其他条件和简单切片表达式相同。

#### 使用make()函数构造切片

上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的`make()`函数

>make([]T, size, cap)

- T:切片的元素类型
- size:切片中元素的数量
- cap:切片的容量

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）

* 要检查切片是否为空，请始终使用`len(s) == 0`来判断，而不应该使用`s == nil`来判断。
* 切片之间是不能比较的，我们不能使用`==`操作符来判断两个切片是否含有全部相等元素。 
* 切片唯一合法的比较操作是和`nil`比较。 
* 一个`nil`值的切片并`没有底层数组` ，一个`nil`值的切片的长度和容量都是0。
* 但是我们不能说一个长度和容量都是0的切片一定是`nil`

```go
// 切片的赋值拷贝
s1 := make([]int, 3) //[0 0 0]
s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
s2[0] = 100
fmt.Println(s1) //[100 0 0]
fmt.Println(s2) //[100 0 0]
// 拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，

// 切片遍历
// 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。

// append()方法为切片添加元素
// Go语言的内建函数append()可以为切片动态添加元素。 
// 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。
// 通过var声明的零值切片可以在append()函数直接使用，无需初始化。  
var s []int
s = append(s, 1)        // [1]  //声明后就可以用 不需要初始化
s = append(s, 2, 3, 4)  // [1 2 3 4]
s2 := []int{5, 6, 7}  
s = append(s, s2...)    // [1 2 3 4 5 6 7]
// 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。
// 当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。
// “扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。
// 1,append()函数将元素追加到切片的最后并返回该切片。
// 2,切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。
```

### 切片的扩容策略

* 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。
* 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），
* 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
* 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。
* 需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。

### 使用copy()函数复制切片

* 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。

* Go语言内建的`copy()`函数可以迅速地将一个切片的数据复制到另外一个切片空间中，`copy()`函数的使用格式如下：

  ```go
  copy(destSlice, srcSlice []T)
  // srcSlice: 数据来源切片
  // destSlice: 目标切片
  ```

### 从切片中删除元素

```go
// Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 
// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
// 要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)
```

# map

* Go语言中提供的映射关系容器为`map`，其内部使用`散列表（hash）`实现。

* map是一种无序的基于`key-value`的数据结构，Go语言中的map是引用类型，必须初始化才能使用。

* >```go
  >// map 定义
  >map[KeyType]ValueType
  >// KeyType:表示键的类型。
  >// ValueType:表示键对应的值的类型。
  >// map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：
  >make(map[KeyType]ValueType, [cap])
  >// 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。
  >```

